<div class="d3_plot" id="history_chart"></div>
<script src="https://d3js.org/d3.v4.js"></script>
<script id='d3_history_chart' type="text/javascript">

$(document).ready(function() {
  setup_d3();
});

function update_d3_regions() {
  all_regions.forEach(function (r) {
    if (selected_regions.has(r)) {
      $('[region=' + r + ']').attr('visibility', 'visible');
    } else {
      $('[region=' + r + ']').attr('visibility', 'hidden');
    }
  })
}

function setup_d3() {
  // set the dimensions and margins of the graph
  var rating_span = '{{ time_span }}';
  var root_width;
  var margin;
  var width;
  var height;
  if (rating_span === 'all') {
    root_width = $('.site_wrapper').width();
    margin = {top: 10, right: 80, bottom: 30, left: 50};
    width = root_width - margin.left - margin.right;
    height = 400 - margin.top - margin.bottom;
    if ($(window).width() < 650) {
      height = 250 - margin.top - margin.bottom;
    }
  }
  else {
    root_width = $('.site_intro').width();
    margin = {top: 10, right: 80, bottom: 30, left: 50};
    width = root_width - margin.left - margin.right;
    height = 300 - margin.top - margin.bottom;
    if ($(window).width() < 650) {
      height = 200 - margin.top - margin.bottom;
    }
  }
  var d3_x;
  var d3_y;
  var x_axis;
  var x_min;
  var x_max;
  var x_season_gaps;
  
  var axis_year = 2014;
  var axis_labels = [' Spring', 'MSI', ' Summer', 'Worlds'];
  var x_axis_ticks = [];
  var x_axis_labels = [];
  var x_axis_labels_mobile = [];
  for (var i = 0; i < 100; i++) {
    if (i%4 == 0) ++axis_year;
    x_axis_labels_mobile.push(axis_year);
    if (i%2 == 0) {
      x_axis_labels.push(axis_year + axis_labels[i%4]);
      continue;
    }
    x_axis_labels.push(axis_labels[i%4]);
  }


  // append the svg object to the body of the page
  var d3_svg = d3.select("#history_chart")
    .append("svg")
      .attr("width", width + margin.left + margin.right)
      .attr("height", height + margin.top + margin.bottom)
    .append("g")
      .attr("transform",
            "translate(" + margin.left + "," + margin.top + ")");

  // Clip rect to only show data in the plot
  d3_svg.append("defs").append("svg:clipPath")
    .attr("id", "clip")
    .append("svg:rect")
    .attr("width", width )
    .attr("height", height )
    .attr("x", 0)
    .attr("y", 0);
  var plot_area = d3_svg.append('g')
    .attr('id', 'plot_area')
    .attr("clip-path", "url(#clip)");

  // Add brushing
  var brush = d3.brushX()
    .extent( [ [0,0], [width,height] ] )
    .on("end", updateChart);
  plot_area.append("g")
    .attr("class", "brush")
    .call(brush);

  // legend div
  var legend = d3.select("#history_chart")
    .append("div")
    .attr("class", "history_legend")
    .style("top", "5px")
    .style("left", (root_width - margin.right) + "px");

  // Add Y axis
  d3_y = d3.scaleLinear()
    .domain([1200, 2000]) // Reasonable elo rating range
    .range([height, 0]);
  d3_svg.append("g")
    .call(d3.axisLeft(d3_y));

  // Initial X axis
  d3_x = d3.scaleLinear()
    .domain([0, 1])
    .range([0, width]);
  x_axis = d3_svg.append("g")
    .attr("transform", "translate(0," + height + ")")
    .call(d3.axisBottom(d3_x).tickValues([]));

  var loading_text = d3_svg
    .append('text')
      .attr('id', 'loading_text')
      .attr('x', width/2 - 100)
      .attr('y', height/2 - 10)
      .text('Loading Data');

  // Get data and set axes
  var ratings_url = '/history/all_teams/{{ time_span|safe }}';
  d3.json(ratings_url, function(data) {
    x_min = data.season_start_indices[0];
    x_max = data.max_index;
    x_season_gaps = data.season_start_indices;
    for (var i = 0; i < x_season_gaps.length - 1; i++) {
      x_axis_ticks.push(Math.round(x_season_gaps[i] + (x_season_gaps[i+1] - x_season_gaps[i]) / 2));
    }

    // Scale X axis
    d3_x = d3.scaleLinear()
      .domain([x_min, x_max])
      .range([0, width]);
    x_axis.call(
      d3.axisBottom(d3_x)
        .tickValues(x_axis_ticks)
        .tickSize(0)
        .tickFormat(function (d, i) {
          if (small_plot) return (i%4 ? "" : x_axis_labels_mobile[i]);
          return (i%3 ? "" : x_axis_labels[i]);
        }));

    // Show season boundaries
    plot_area.selectAll('.season_gap_rect')
      .data(x_season_gaps)
    .enter().append('rect')
      .attr('class', 'season_gap_rect')
      .attr('x', d => d3_x(d - 1) )
      .attr('y', 0)
      .attr('width', d3_x(1) - d3_x(0) )
      .attr('height', height);

    // Add line for each team
    data.teams.forEach(function (t) {
      //console.log(t);
      plot_area.selectAll(".line")
        .data(t.team_rating_history)
      .enter().append("path")
        .attr('class', t.team_name + '_line')
        .attr('team_name', t.team_name)
        .attr('region', t.region)
        .attr("fill", "none")
        .attr("stroke", t.color)
        .attr("stroke-width", 1.5)
        .attr("d", d3.line()
          .x(function(d) { return d3_x(d.rating_index) })
          .y(function(d) { return d3_y(d.rating) })
        )
        .on("mouseover", function(d) {
          let team_class = this.getAttribute('team_name') + '_line';
          let lines = $('[class~="'+team_class+'"]');
          lines
            .attr('stroke-width', 4)
            .attr('class', team_class + ' dropshadow')
            .appendTo(lines.parent());
          return legend.style("visibility", "visible");
        })
        .on("mousemove", function(d) {
          let goal = d3_x.invert(d3.mouse($('#plot_area')[0])[0]);
          closest_rating = d.reduce(function(prev, curr) {
            return (Math.abs(curr.rating_index - goal) < Math.abs(prev.rating_index - goal) ? curr : prev);
          });
          let hover_text = this.getAttribute('team_name') + ' ' + this.getAttribute('region') + '\n' + Math.round(closest_rating.rating);
          legend.text(hover_text);
        })
        .on("mouseout", function() {
          let team_class = this.getAttribute('team_name') + '_line';
          $('[class~="'+team_class+'"]')
            .attr('stroke-width', 1.5)
            .attr('class', team_class);
          return legend.style("visibility", "hidden");
        });
    });
    loading_text.remove();
    update_d3_regions();
  });

  // Set up chart zooming
  var idleTimeout;
  function idled() { idleTimeout = null; }

  function updateChart() {
    extent = d3.event.selection
    // If no selection, back to initial coordinate. Otherwise, update X axis domain
    if (!extent) {
      if (!idleTimeout) return idleTimeout = setTimeout(idled, 350); // Wait a little bit
      d3_x.domain([x_min, x_max]);
    } else {
      d3_x.domain([ d3_x.invert(extent[0]), d3_x.invert(extent[1]) ])
      plot_area.select(".brush").call(brush.move, null) // Remove the grey brush area as soon as the selection has been done
    }

    // Update axis and line position
    plot_area.selectAll("path")
      .transition().duration(1000)
      .attr("d", d3.line()
        .x(function(d) { return d3_x(d.rating_index) })
        .y(function(d) { return d3_y(d.rating) })
      );
    plot_area.selectAll(".season_gap_rect")
      .transition().duration(1000)
      .attr('x', d => d3_x(d - 1) )
      .attr('width', d3_x(1) - d3_x(0) );
    x_axis.transition().duration(1000).call(
      d3.axisBottom(d3_x)
        .tickValues(x_axis_ticks)
        .tickSize(0)
        .tickFormat(function (d, i) {
          if (small_plot) return (i%4 ? "" : x_axis_labels_mobile[i]);
          return (i%3 ? "" : x_axis_labels[i]);
        }) );
  }
}

</script>
